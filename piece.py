import shape, constants
from logger import get_logger

log = get_logger()

class Piece:
  """The class representing a Tetramino (or piece).

  Contains information about the coordinates and orientation of the piece.
  """
  def __init__(self, id, x=0, y=0, rotation=0):
    """Inits the Piece.

    Args:
      id (int): The ID corresponding to the shape of the Piece, which (as documented in shape.py)
      are 0 / empty, 1 / I, 2 / O, 3 / T, 4 / S, 5 / Z, 6 / J, 7 / L.
      x (int): The starting X coordinate of the Piece (From left to right).
      y (int): The starting Y coordinate of the Piece (From top to down).
      rotation (int): The rotation state of the Piece, as documented in shape.py (positive is 
      clockwise, negative is anti-clockwise).
    """
    self.x = x
    self.y = y
    self.id = id
    self.rotation = rotation

    self.shape_coords = None # the generic coordinates occupied by a shape of the Piece
    self.coords = []
    self.prev_coords = []

  def rotate(self, value):
    """Rotates the Piece based on the given value.

    Args:
      value (int): The rotation to apply to the Piece (positive is clockwise, negative is 
      anti-clockwise).
    """
    self.rotation += value
    self.rotation = self.rotation % len(shape.SHAPES_COORDS[self.id])

  def move(self, x, y, rotation):
    """Moves the Piece based on a given move.

    Args:
      x (int): The number of cells to move the Piece in the x direction (From left to right).
      y (int): The number of cells to move the Piece in the y direction (From top to down).
      rotation (int): The amount to rotate the Piece (positive is clockwise, negative is 
      anti-clockwise).
    """
    self.prev_coords = self.coords
    self.x += x
    self.y += y

    self.rotate(rotation)
    self.coords = self.update_coords()

    return self.prev_coords, self.coords

  def update_coords(self):
    """Updates the coordinates of a Piece based on its own information.
    """
    self.coords = []
    self.shape_coords = shape.SHAPES_ID[self.id].get_coord_occupied(self.rotation)

    for coord in self.shape_coords:
      self.coords.append([self.y + coord[0], self.x + coord[1]])

    return self.coords

  def simulate_move(self, x, y, rotation):
    """Simulates a move and returns the coordinates of the Piece without altering
    its actual information.

    Args:
      x (int): The number of cells to move the Piece in the x direction (From left to right).
      y (int): The number of cells to move the Piece in the y direction (From top to down).
      rotation (int): The amount to rotate the Piece (positive is clockwise, negative is 
      anti-clockwise).
    Returns:
      The coordinates of the Piece as a Lists of Lists of (Y, X) for each cell that it occupies.
    """
    curr_x = self.x + x
    curr_y = self.y + y
    curr_rotation = self.rotation + rotation
    curr_rotation = curr_rotation % len(shape.SHAPES_COORDS[self.id])

    coords = []
    shape_coords = shape.SHAPES_ID[self.id].get_coord_occupied(curr_rotation)
    for coord in shape_coords:
      coords.append([curr_y + coord[0], curr_x + coord[1]])

    return coords
    
  def is_valid_state(self, board):
    """Returns True if the current state of the Piece is legal in a given board.

    Args:
      board (2D Array): The 2D array corresponding to the board state that is being
      validated.
    """
    for coord in self.coords:
      x = coord[1]
      y = coord[0]

      if x < 0 or x >= constants.BOARD_WIDTH or y < 0 or y >= constants.BOARD_HEIGHT:
        return False
      if board[y][x] != constants.PIECE_ID_EMPTY and board[y][x] != constants.PIECE_ID_CURRENT:
        return False

    return True

  def get_y_coord_shift(self):
    """Calculates the amount that the Piece will fall after a move.
    """
    # TODO: Implement based on a move generated by the board.
    #return FRAME_DELAY / FRAMES_PER_GRIDCELL_Y[STARTING_LEVEL]

    # return a single drop for the time being for simplicity
    return 1

  def get_id(self):
    return self.id

  def print_info(self):
    """Prints the data of the Piece.
    """
    print("current id is:", self.get_id(), "/", shape.SHAPES_NAMES[self.id],
          "Rotation:", self.rotation)
    print("coords:", self.get_coords())

    print("current piece arrangement")
    for line in shape.SHAPES_COORDS[self.get_id()][self.rotation]:
      print("|", line, "|")

  def print_simulated_move(self, x, y, rotation_val):
    """Prints the data of the Piece, given a simulated move.
    
    Args:
      x (int): The number of cells to move the Piece in the x direction (From left to right).
      y (int): The number of cells to move the Piece in the y direction (From top to down).
      rotation (int): The amount to rotate the Piece (positive is clockwise, negative is 
      anti-clockwise).
    """
    rotation = self.rotation + rotation_val
    rotation = rotation % len(shape.SHAPES_COORDS[self.id])

    print("current id is:", self.get_id(), "/", shape.SHAPES_NAMES[self.id],
          "Rotation:", rotation)
    print("coords:", self.simulate_move(x, y, rotation_val))

    print("current piece arrangement")
    for line in shape.SHAPES_COORDS[self.get_id()][rotation]:
      print("|", line, "|")

  def get_coords(self):
    """Returns the coordinates of cells occupied by the Piece.
    """
    return self.coords

  def get_prev_coords(self):
    """Returns the previous coordinates of cells occupied by the Piece.
    """
    return self.prev_coords

  def get_rotation(self):
    """Returns the current rotation value of the Piece.
    """
    return self.rotation
